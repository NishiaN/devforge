# OpenClawとは？（セルフホスト型パーソナルAIアシスタント／エージェント）

## TL;DR

OpenClawは、**自分のPC/サーバー上で動かす**「実行できるAIアシスタント」です。普段使っている **WhatsApp / Telegram / Slack / Discord / iMessage / Teams** などの“チャットの入り口”から指示でき、**コマンド実行・ブラウザ操作・ファイル操作・メール/カレンダー連携**などを（設定した範囲で）代わりに実行します。

------

## 1. OpenClawの概要

### 1.1 何を解決するもの？

従来のチャットAIは「答える（助言する）」が中心でした。一方OpenClawは、**あなたの環境に接続し、ツールを使って“実際に作業を進める”**ことを主眼にしたエージェント型アシスタントです。

### 1.2 “セルフホスト（自前運用）”の意味

OpenClawは基本的に **自分のデバイス/自分のインフラ**で動かす設計です。会話・設定・メモリ等をローカルに置けるため、**プライバシーや制御性を高めやすい**のが特徴です。

------

## 2. できること（主な機能）

### 2.1 いつものチャットアプリから使える（マルチチャネル）

OpenClawは、複数のメッセージング/チャットチャンネルに接続して返答・実行できます（例：WhatsApp、Telegram、Slack、Discord、iMessage、Teams など）。

### 2.2 “話す”だけでなく“実行する”

設定した権限の範囲で、次のようなアクションを統合できます（プロジェクト/構成により範囲は変わります）：

- シェルコマンド実行、ファイル作成・整理
- ブラウザ自動化（調査、入力、反復作業）
- メール処理、カレンダー管理、タスク実行

### 2.3 常駐・スケジュール実行（“呼ばれてなくても動く”）

一定間隔で起動するスケジューラ（ハートビート）等により、**常駐監視→必要時に通知**のような運用が可能です。

### 2.4 ローカルに“記憶”を持てる（Local-first / SQLite）

OpenClawはローカルSQLite DBにデータを保持する設計が紹介されており、**設定次第で外部送信を最小化**しやすい思想です。

### 2.5 スキル（拡張）で能力を足せる

“スキル”として拡張でき、コミュニティ/マーケット（ClawHub）を通じた共有も想定されています。一方で後述の通り、**拡張はセキュリティ面の注意が必須**です。

------

## 3. 仕組み（ざっくりアーキテクチャ）

### 3.1 Gateway（コントロールプレーン）中心の構成

OpenClawは一般に、**Gatewayがチャット/CLI/管理UIなどの入口を束ね、エージェント実行系へルーティングする**ハブ構造として説明されています。

### 3.2 Control UI / CLI

導入直後の確認や操作として、CLIでGateway状態を見たり、Control UI（ダッシュボード）を開く導線が公式ドキュメントに示されています。

------

## 4. 導入の流れ（最短イメージ）

> ここでは「全体の流れ」が分かる最小手順だけ書きます（詳細・要件は公式ドキュメント参照）。

1. インストール（WindowsはPowerShell、macOS/Linuxはシェル）
2. オンボーディング（認証・Gateway設定・チャンネル等の初期設定）
3. Gatewayの稼働確認
4. ダッシュボード（Control UI）を開く

------

## 5. 代表的なユースケース

### 5.1 個人の“作業代行”アシスタント

- 受信箱の整理、定型メール送信、カレンダー調整
- 旅行（チェックイン等）や日々のリマインド

### 5.2 開発・運用の“常駐エージェント”

- Discord/Slackを入口に、社内ツール・サーバー操作・定期監視
- “閉域＋ゼロトラスト”前提での運用設計（例：VPN/Tailscale前提の構成例）

### 5.3 スマートホーム連携の足回り（周辺エコシステム）

OpenClawは、スマートホーム機器側が「OpenClaw対応」をうたう事例も出ています（例：ローカルAIハブがOpenClawフレームワーク対応を表明）。

------

## 6. セキュリティと注意点（ここが最重要）

OpenClawは“実行できる”ぶん、**権限を持った自動化**になります。安全に使うため、公式は大枠として「誰が話せるか→どこまでやらせるか→モデルは最後（悪用され得る前提）」の順で設計せよ、という考え方を示しています。

### 6.1 サンドボックス（Docker）で被害範囲を抑える

ツール実行をDocker等で隔離する“サンドボックス”を使える、という説明があります（完全な境界ではないが、被害半径を下げる目的）。

### 6.2 スキル（拡張）由来のマルウェア懸念

最近（2026年1〜2月）に、スキル配布を悪用したマルウェア混入が問題になったと複数の報道があります。
 それを受け、OpenClaw側は **VirusTotal連携でスキルをスキャン**する取り組みを発表しています。

### 6.3 安全運用チェックリスト（実務向け）

- **チャンネル/ユーザーの許可制**：DMペアリング、許可リスト、メンション必須など
- **実行スコープの絞り込み**：触っていいディレクトリ/コマンド/ネットワークを限定
- **サンドボックスON**：可能なら隔離実行
- **スキルは“実行ファイル相当”として扱う**：コード確認、出所確認、最小権限
- **秘密情報の扱い**：APIキー/トークンは分離、漏えい前提でローテーション計画

------

## 7. OpenClawが向いている人／向かない人

### 向いている

- 「チャットで指示→環境で実行」まで一気通貫にしたい
- 自分の端末/インフラで動かして **制御性・運用性**を握りたい

### 向かない（慎重に）

- 端末権限を渡す自動化に抵抗がある
- セキュリティ設計（許可制・隔離・監査）を用意できない

------

## 8. 似たものとの違い（ざっくり）

- **“個人用・ローカル運用・チャット入口重視”**が強い（WhatsApp等へ寄せる）
- Gateway中心で、複数チャネルと実行系をまとめる構造として語られることが多い 
- その代わり、**拡張・権限・実行**が絡むので、セキュリティ設計が成果を左右する 

-----------------------------------------------------

## Claude Code（開発）× OpenClaw（運用）の責務分離 ── CLAUDE.md 肥大化問題とベストプラクティス

以下、「**Claude Code＝開発**」「**OpenClaw＝運用**」を**ちゃんと責務分離**しつつ、いちばんハマりがちな **CLAUDE.md 肥大化**を止めるための“実務ベストプラクティス”を、設計思想→具体構成→テンプレの順でまとめます。

------

## 1) まず前提：CLAUDE.md が太るほど精度が落ちやすい

Claude Code は **会話・読んだファイル・コマンド出力・CLAUDE.md** ぜんぶが同じ「コンテキスト窓」を消費し、**埋まるほど性能が劣化**します。巨大な CLAUDE.md を毎回注入すると、軽い作業でも常に重い前提を背負うことになります。 

------

## 2) 「開発×運用」責務分離の基本形（Dev / Ops / Shared）

### Dev（Claude Code が担当）

- 仕様→設計→実装→テスト→PR（コード変更のライフサイクル）
- コーディング規約、テスト規約、プロジェクト固有の設計判断
- IaC 変更“そのもの”は Dev だが、**運用の期待値（SLO/アラート条件）**は Shared で合意してから反映

### Ops（OpenClaw が担当）

- 監視・アラート・オンコール・一次切り分け・復旧手順（Runbook）
- 運用オートメーション（定期点検、ヘルスロールアップ、証跡収集）
- 失敗時に「何が起きたか」を証拠で出す（run_id / 依存先 / エラー根拠 等） 

### Shared（両者が参照する“契約”）

- SLO/SLA、アラート設計、エスカレーション、ロール（IC/Comms 等）
- 変更管理（リリース手順・ロールバック基準・フラグ運用）
- セキュリティ（権限境界、Secrets、許可ドメイン、実行禁止コマンド）

------

## 3) CLAUDE.md 肥大化を止める「3層分割」——ここが肝

Claude Code 側は **“常時ロードされるもの”を最小化**して、残りは**必要な時だけロード**に逃がします。

### 層A：薄い「ルート CLAUDE.md」＝“ルーティング用インデックス”

ルートは「WHY/WHAT/HOW の骨格 + 参照先」だけ。
 長い手順や細かい規約は置かない（置くなら参照先）。
 ※ CLAUDE.md の役割を「毎回読む最小限の憲法」にするのがコツ。

### 層B：高優先・常時適用の規約は `.claude/rules/` に分割

公式に **`.claude/rules/` 配下の複数 md を自動ロード**でき、**`.claude/CLAUDE.md と同じ優先度\**で扱えます。 :contentReference[oaicite:2]{index=2}   さらに \**YAML frontmatter の `paths:` で“対象ファイルに触る時だけ適用”\**もできます。 
 → これで「フロントだけ」「APIだけ」「infraだけ」みたいに\**局所化**でき、肥大化を止められます。

### 層C：長い手順・運用手順・レア手順は “Skills” に逃がす

Skills は `SKILL.md` として定義し、**必要な時だけ自動ロード or `/slash` で呼び出し**ができます。 
 → 「デプロイ手順」「障害対応チェック」「ログ収集」みたいな長文は **Skills 化**が相性◎。

------

## 4) もう一手：モノレポでも“ディレクトリ単位で記憶を分離”できる

Claude Code のメモリは、**cwd から上に向かって CLAUDE.md を再帰ロード**し、さらに**サブツリー内のネスト CLAUDE.md は“その配下のファイルを触ったときだけ”含まれる**動きがあります。 
 つまり、例えばこうできます：

- `apps/web/CLAUDE.md`（Web 専用）
- `services/api/CLAUDE.md`（API 専用）
- `infra/CLAUDE.md`（IaC 専用）
- `ops/` は OpenClaw 側に寄せる、または別リポ

------

## 5) Claude Code（開発）× OpenClaw（運用）の“綺麗な接続点”

### 推奨アーキテクチャ（実務で揉めにくい）

**A案：リポジトリ分離（いちばん事故りにくい）**

- `product-repo/`（OpenClaw は触らない or Read-only）
- `ops-repo/`（OpenClaw が常駐・運用のSSOT）
- 連携は “成果物（Runbook/Config/ダッシュボード定義）” のみ

**B案：同一リポでディレクトリ分離**

- `product/`（Claude Code 主戦場）
- `ops/`（OpenClaw 主戦場：runbooks、alerts、oncall、evidence 収集）
- Claude Code は `ops/` を基本 Read-only にしてもいい（後述の権限で縛る）

### “引き渡し契約”として最低限そろえるファイル

- `docs/ops/SLO.md`
- `docs/ops/ALERTS.md`（アラート→一次切り分け→エスカレーション）
- `docs/ops/RUNBOOKS/*`
- `docs/ops/POSTMORTEM_TEMPLATE.md`
- `docs/ops/RELEASE_AND_ROLLBACK.md`

OpenClaw の運用は「証拠を残す」が強いです（例：run_id、依存先、HTTP status/latency 等）。この思想に合わせて Runbook も **“手順”だけでなく“取得すべき証跡”**を先に書くのが強いです。 

------

## 6) 最小テンプレ（この形にすると太りにくい）

### (1) ルート `.claude/CLAUDE.md`（薄く）

- プロジェクト目的
- 重要コマンド（build/test/lint）
- コード構造の地図
- ルールの置き場所（rules/skills/docs）へのリンク
- “運用は ops/ を参照、CLAUDE.md に運用手順を書かない”宣言

### (2) `.claude/rules/`（分割＋paths）

- `general.md`（全体の命名・Lint・テスト方針）
- `frontend/react.md`（paths: `apps/web/**/*.{ts,tsx}`）
- `backend/api.md`（paths: `services/api/**/*.ts`）
- `infra/iac.md`（paths: `infra/**`）
   （paths 指定の書き方は公式例の通り） 

### (3) `.claude/skills/`（長手順の格納庫）

- `deploy/SKILL.md`（リリース手順・ロールバック）
- `incident-triage/SKILL.md`（一次切り分け・証跡収集）
- `dependency-upgrade/SKILL.md`（依存更新の段取り）
   Skills は「必要時だけ」呼ばせるのが狙いです。 

------

## 7) セキュリティと権限境界（OpenClaw運用とセットで必須）

OpenClaw は“運用で動かすほど強い権限”になりがちなので、Claude Code 側も含めて **許可/拒否を明示**するのが鉄板です。Claude Code には **Read/Edit/WebFetch の allow/deny** があり、危険な領域（例：`~/.aws/**`）を deny できます。 
 また OpenClaw は最近セキュリティ面でも注目されていて、設定不備が問題になり得る、という指摘も出ています。 

------

## 8) ありがちな失敗 → 回避ルール（短く）

- **失敗**：CLAUDE.md に「運用手順」「監視の手順」「インシデント対応」を全部入れる
   **回避**：Runbook は OpenClaw 側（ops-repo/ops/）のSSOT。Claude Code は“参照リンク”だけ。
- **失敗**：規約が全部グローバルで常時適用
   **回避**：`.claude/rules/` + `paths:` で局所化。 
- **失敗**：長い定型手順が毎回ロードされる
   **回避**：Skills 化してオンデマンド。 